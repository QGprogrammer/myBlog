#  垃圾收集算法

***垃圾收集名词汇总***：

* 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
  * 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
  * 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。
  * 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。
  * 

* ·整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

---



从如何判定***对象消亡***的***角度***出发，垃圾收集算法可以划分为“***引用计数式垃圾收集***”（Reference Counting GC）和“***追踪式垃圾收集***”（Tracing GC）两大类，这两类也常被称作“***直接垃圾收集***”和“***间接垃圾收集***”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。

#### 分代收集理论

当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（GenerationalCollection）的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的***经验法则***，它建立在两个分代假说之上：

1. ***弱分代假说***（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。

 	2. ***强分代假说***（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难消亡。

这两个分代假说共同奠定了多款常用的垃圾收集器的***一致的设计原则***：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其***年龄***（年龄即对象***熬过***垃圾收集过程的***次数***）分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为***新生代***（Young Generation）和***老年代***（Old Generation）两个区域。

虽分为两个区域，但是在跨两个区域的收集过程中，难以保证两个年代的对象不会被对方引用，因此收集新生代时候还得再扫描一次老年代，反之亦然。为了解决这个问题，就需要对分代收集理论添加***第三条经验法则***：跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。根据这一假说，可以忽略这总情况得发生而节省系统资源。



#### 标记-清除算法

最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法，在1960年由Lisp之父John McCarthy所提出。如它的名字一样，算法分为“***标记***”和“***清除***”两个阶段：首先***标记***出所有需要回收的对象，在标记完成后，***统一回收***掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

它的***主要缺点***有两个：第一个是执行***效率***不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是内存空间的***碎片化***问题，标记、清除之后会产生大量***不连续***的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。



#### 标记-复制算法

为了***解决***标记-清除算法面对大量可回收对象时***执行效率低***的问题，1969年Fenichel提出了一种称为“***半区复制***”（SemispaceCopying）的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还***存活***着的对象***复制***到***另外一块***上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生***大量***的内存间复制的***开销***，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用***内存缩小为了原来的一半***，空间浪费未免太多了一点。

现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，IBM公司曾有一项专门研究对新生代“***朝生夕灭***”的特点做了更量化的诠释——新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。

在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“***Appel式回收***”。Appel式回收的具体做法是把新生代分为一块***较大的Eden***空间和***两块较小的Survivor***空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。

Appel式回收还有一个充当罕见情况的“***逃生门***”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行***分配担保***（HandlePromotion）。



#### 标记-整理算法

标记复制算法的空间缩小以及频繁的复制操作耗费太多资源。

针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有***存活***的对象都向***内存空间***一端移动，然后***直接清理掉边界以外***的内存。

如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种***极为负重***的操作，而且这种对象移动操作必须***全程暂停用户应用程序***才能进行，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为“Stop The World”。

但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。

基于以上两点，是否移动对象都存在***弊端***，***移动则内存回收时会更复杂******，******不移动则内存分配时会更复杂***。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。此语境中，吞吐量的实质是赋值器（Mutator，可以理解为使用垃圾收集的用户程序，本书为便于理解，多数地方用“用户程序”或“用户线程”代替）与收集器的效率总和。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从侧面印证这点。另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。