#  垃圾收集算法

***垃圾收集名词汇总***：

* 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
  * 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
  * 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。
  * 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。
  * 

* ·整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

---



从如何判定***对象消亡***的***角度***出发，垃圾收集算法可以划分为“***引用计数式垃圾收集***”（Reference Counting GC）和“***追踪式垃圾收集***”（Tracing GC）两大类，这两类也常被称作“***直接垃圾收集***”和“***间接垃圾收集***”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。

#### 分代收集理论

当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（GenerationalCollection）的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的***经验法则***，它建立在两个分代假说之上：

	1. ***弱分代假说***（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
 	2. ***强分代假说***（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难消亡。

这两个分代假说共同奠定了多款常用的垃圾收集器的***一致的设计原则***：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其***年龄***（年龄即对象***熬过***垃圾收集过程的***次数***）分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为***新生代***（Young Generation）和***老年代***（Old Generation）两个区域。

虽分为两个区域，但是在跨两个区域的收集过程中，难以保证两个年代的对象不会被对方引用，因此收集新生代时候还得再扫描一次老年代，反之亦然。为了解决这个问题，就需要对分代收集理论添加***第三条经验法则***：跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。根据这一假说，可以忽略这总情况得发生而节省系统资源。



#### 标记-清除算法

最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法，在1960年由Lisp之父John McCarthy所提出。如它的名字一样，算法分为“***标记***”和“***清除***”两个阶段：首先***标记***出所有需要回收的对象，在标记完成后，***统一回收***掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

它的***主要缺点***有两个：第一个是执行***效率***不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是内存空间的***碎片化***问题，标记、清除之后会产生大量***不连续***的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。



#### 标记-复制算法

