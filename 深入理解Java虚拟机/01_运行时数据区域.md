#  01_运行时数据区域

*方法区、虚拟机栈、本地方法栈、堆、程序计数器。*



## 程序计数器

***线程私有***

程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的***字节码的行号指示器***。循环、跳转、线程恢复等基础功能都依赖这个计数器完成。此区域是唯一一个在《Java虚拟机规范》中没有规定OutOfMemoryError的区域。

**注意：**若程序正在执行的是本地（Native）方法，这个计数器值应为Undefined。



## Java虚拟机栈

***线程私有***

Java虚拟机栈（Java Virtual Machine Stack）的生命周期与线程相同。

每个方法执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于***存储局部变量表、操作数栈、动态连接、方法出口***等信息。

局部变量表存放了编译期可知的各种Java虚拟机***基本数据类型***（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。

这些数据类型在局部变量表中的存储空间以***局部变量槽***（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在***编译期间完成分配***。一个变量槽可能占用32比特或64比特，由虚拟机自行决定。

在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出***StackOverflowError***异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出***OutOfMemoryError***异常。



## 本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。



## Java堆

***线程共享***

对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中***最大的一块***。Java堆是被所有线程共享的一块内存区域，在虚拟机***启动时创建***。Java世界里***几乎所有***的对象实例都是存于此处。

Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”。

根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在***逻辑上***它应该被视为***连续***的。



## 方法区

***线程共享***

方法区（Method Area）用于存储已被虚拟机加载的***类型信息、常量、静态变量***、即时编译器编译后的***代码缓存***等数据。

在JDK 8以前很多程序员把方法区称为“永久代”，考虑到HotSpot未来的发展，在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了[插图]，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全***废弃了永久代***的概念，改用与JRockit、J9一样在本地内存中实现的***元空间***（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。

***运行时常量池***（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant PoolTable），用于存放编译期生成的各种***字面量与符号引用***，这部分内容将在类加载后存放到方法区的运行时常量池中。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备***动态性***，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是***String类***的***intern()***方法。



## 直接内存

直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。

在JDK 1.4中新加入了***NIO***（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用***Native函数库直接分配堆外内存***，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为***避免了在Java堆和Native堆中来回复制数据***。

显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。